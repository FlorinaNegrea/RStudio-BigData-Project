get_cp <- function(x) {
min <- which.min(x$cptable[,"xerror"])
cp <- x$cptable[min, "CP"]
return(cp)
}
get_min_error <- function(x) {
min <- which.min(x$cptable[, "xerror"])
xerror <- x$cptable[min, "xerror"]
return(xerror)
}
# Aplicarea funcțiilor pe modelele create
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
mutated_grid %>%
arrange(error) %>%
top_n(-6, wt=error)
# Antrenarea modelului optimal folosind cei mai buni parametri
# Antrenarea modelului optimal folosind cei mai buni parametri
optimal_tree <- rpart(
formula = price ~ .,
data = gemstone_train,
method = "anova",
control = list(minsplit = 15, maxdepth = 9, cp = 0.01)
)
# Vizualizarea modelului optimal
rpart.plot(optimal_tree)
# Evaluarea modelului optimal pe setul de testare
pred_optimal <- predict(optimal_tree, newdata = gemstone_test)
rmse_optimal <- RMSE(pred = pred_optimal, obs = gemstone_test$price)
print(paste("RMSE al modelului optimal: ", rmse_optimal))
new_data <- gemstone_test[1, ]
# Facem o predicție pentru o instanță nouă (de exemplu, prima observație din setul de testare)
new_data <- gemstone_test[1, ]
prediction <- predict(optimal_tree, newdata = new_data)
cat("Prețul estimat al noului zirconiu cubic este:", prediction, "\n")
print(paste("RMSE al modelului optimal: ", rmse_optimal))
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
mod_prices_without_table_width <- lm(data = GemStone, price ~ carat + cut +color+clarity+length+height)
summary(mod_prices_without_table_width)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
GemStone <-read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
mod_prices_without_table_width <- lm(data = GemStone, price ~ carat + cut +color+clarity+length+height)
summary(mod_prices_without_table_width)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
gemstones <- tibble(
carat = 0.48,
cut = "Very Good",
color = "D",
clarity = "IF",
length = 5.08,
height = 3.09,
)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "prediction")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "prediction")
predicted_prices <- predict(mod_prices_without_table_width, newdata = GemStone)
actual_prices <- GemStone$price
rmse <- sqrt(mean((predicted_prices - actual_prices)^2))
# Afișarea RMSE
print(paste("RMSE pentru modelul 'mod_prices_without_table_width':", rmse))
actual_values <- gemstone_test$price
mean_actual <- mean(actual_values)
sst <- sum((actual_values - mean_actual)^2)
sse <- sum((actual_values - pred_optimal)^2)
r_squared <- 1 - (sse / sst)
print(paste("R² pentru modelul arborelui de decizie: ", r_squared))
print(paste("RMSE al modelului optimal: ", rmse_optimal))
library(tidyverse)
library(dplyr)
library(modelr)
library(scatterplot3d)
rm(list = ls())
GemStone <-read_csv("cubic_zirconia.csv")
View(GemStone)
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
mod_prices_all <- lm(data=GemStone, price ~ .)
summary(mod_prices_all)
mod_prices_without_table_width <- lm(data = GemStone, price ~ carat + cut +color+clarity+length+height)
summary(mod_prices_without_table_width)
mod_prices_carat <- lm(data=GemStone, price ~ carat)
summary(mod_prices_carat)
grid_carat <- GemStone %>%
data_grid(carat = seq_range(carat, 100)) %>%
add_predictions(mod_prices_carat, "price")
ggplot(GemStone, aes(carat, price)) +
geom_point() +
geom_line(data = grid_carat, color = "red", size = 1)
confint(mod_prices_carat)
mod_prices_cut <- lm(data=GemStone, price ~ cut)
summary(mod_prices_cut)
confint(mod_prices_cut)
mod_prices_width <- lm(data=GemStone, price ~ width)
summary(mod_prices_width)
gemstones <- tibble(
carat = 0.48,
cut = "Very Good",
color = "D",
clarity = "IF",
length = 5.08,
height = 3.09,
)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "prediction")
predicted_prices <- predict(mod_prices_without_table_width, newdata = GemStone)
actual_prices <- GemStone$price
rmse <- sqrt(mean((predicted_prices - actual_prices)^2))
# Afișarea RMSE
print(paste("RMSE pentru modelul 'mod_prices_without_table_width':", rmse))
rm(list = ls())
library(tidyverse)
library(dplyr)
library(modelr)
rm(list = ls())
GemStone <-read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(cut, price)) + geom_point() + geom_smooth()
library(tidyverse)
library(dplyr)
library(modelr)
rm(list = ls())
GemStone <-read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
library(tidyverse)
library(rsample)
library(dplyr)
library(rpart)
library(rpart.plot)
library(caret)
rm(list = ls())
GemStone <- read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
set.seed(123)
ggplot(GemStone, aes(x = price)) +
geom_density(fill = "blue", alpha = 0.5) +
geom_density(color = "blue") +
labs(x = "Pretul zirconiului", y = "Densitate") +
theme_minimal()
gemstone_split <- initial_split(GemStone, prop = 0.7)
gemstone_train <- training(gemstone_split)
gemstone_test <- testing(gemstone_split)
m1 <- rpart(
formula = price ~ .,
data = gemstone_train,
method = "anova"
)
rpart.plot(m1)
plotcp(m1)
m1$cptable
m1
hyper_grid <- expand.grid(
minsplit = seq(7, 20, 1),
maxdepth = seq(6, 13, 1)
)
head(hyper_grid)
models <- list()
for (i in 1:nrow(hyper_grid)) {
minsplit <- hyper_grid$minsplit[i]
maxdepth <- hyper_grid$maxdepth[i]
models[[i]] <- rpart(
formula = price ~. ,
data = gemstone_train,
method = "anova",
control = list(minsplit = minsplit, maxdepth = maxdepth)
)
}
get_cp <- function(x) {
min <- which.min(x$cptable[,"xerror"])
cp <- x$cptable[min, "CP"]
return(cp)
}
get_min_error <- function(x) {
min <- which.min(x$cptable[, "xerror"])
xerror <- x$cptable[min, "xerror"]
return(xerror)
}
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
mutated_grid %>%
arrange(error) %>%
top_n(-6, wt=error)
optimal_tree <- rpart(
formula = price ~ .,
data = gemstone_train,
method = "anova",
control = list(minsplit = 15, maxdepth = 9, cp = 0.01)
)
rpart.plot(optimal_tree)
pred_optimal <- predict(optimal_tree, newdata = gemstone_test)
rmse_optimal <- RMSE(pred = pred_optimal, obs = gemstone_test$price)
print(paste("RMSE al modelului optimal: ", rmse_optimal))
new_data <- gemstone_test[1, ]
prediction <- predict(optimal_tree, newdata = new_data)
cat("Prețul estimat al noului zirconiu cubic este:", prediction, "\n")
actual_values <- gemstone_test$price
mean_actual <- mean(actual_values)
sst <- sum((actual_values - mean_actual)^2)
sse <- sum((actual_values - pred_optimal)^2)
r_squared <- 1 - (sse / sst)
print(paste("R² pentru modelul arborelui de decizie: ", r_squared))
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(cut, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(color, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(clarity, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(table, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(length, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(width, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(height, price)) + geom_point() + geom_smooth()
library(tidyverse)
library(dplyr)
library(modelr)
rm(list = ls())
GemStone <-read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
GemStone %>%
ggplot(aes(cut, price)) + geom_point() + geom_smooth()
mod_prices_without_table_width <- lm(data = GemStone, price ~ carat + cut +color+clarity+length+height)
summary(mod_prices_without_table_width)
gemstones <- tibble(
carat = 0.48,
cut = "Very Good",
color = "D",
clarity = "IF",
length = 5.08,
height = 3.09,
)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "prediction")
predicted_prices <- predict(mod_prices_without_table_width, newdata = GemStone)
actual_prices <- GemStone$price
library(tidyverse)
library(dplyr)
library(modelr)
rm(list = ls())
GemStone <-read_csv("cubic_zirconia.csv")
View(GemStone)
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
GemStone <-read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
GemStone <- GemStone %>%
select(-...1)
GemStone <- GemStone %>%
select(-depth)
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
GemStone %>%
select_if(is.numeric) %>%
gather(metric, value) %>%
ggplot(aes(value, fill=metric)) +
geom_density(show.legend = FALSE) +
facet_wrap(~metric, scales = "free")
set.seed(123)
GemStone %>%
ggplot(aes(carat, price)) + geom_point() + geom_smooth()
mod_prices_all <- lm(data=GemStone, price ~ .)
summary(mod_prices_all)
mod_prices_carat <- lm(data=GemStone, price ~ carat)
summary(mod_prices_carat)
mod_prices_carat <- lm(data=GemStone, price ~ carat)
summary(mod_prices_carat)
confint(mod_prices_carat)
mod_prices_without_table_width <- lm(data = GemStone, price ~ carat + cut +color+clarity+length+height)
summary(mod_prices_without_table_width)
mod_prices_cut <- lm(data=GemStone, price ~ cut)
summary(mod_prices_cut)
confint(mod_prices_cut)
mod_prices_all <- lm(data=GemStone, price ~ .)
summary(mod_prices_all)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
gemstones <- tibble(
carat = 0.48,
cut = "Very Good",
color = "D",
clarity = "IF",
length = 5.08,
height = 3.09,
)
predict(mod_prices_without_table_width, newdata = gemstones, interval = "confidence")
predict(mod_prices_without_table_width, newdata = gemstones, interval = "prediction")
predicted_prices <- predict(mod_prices_without_table_width, newdata = GemStone)
actual_prices <- GemStone$price
rmse <- sqrt(mean((predicted_prices - actual_prices)^2))
print(paste("RMSE pentru modelul 'mod_prices_without_table_width':", rmse))
rm(list = ls())
library(tidyverse)
library(rsample)
library(dplyr)
library(rpart)
library(rpart.plot)
library(caret)
GemStone <- read_csv("cubic_zirconia.csv")
GemStone <- GemStone %>%
mutate(across(c(cut, color, clarity), factor))
names(GemStone)[names(GemStone) == "x"] <- "length"
names(GemStone)[names(GemStone) == "y"] <- "width"
names(GemStone)[names(GemStone) == "z"] <- "height"
set.seed(123)
ggplot(GemStone, aes(x = price)) +
geom_density(fill = "blue", alpha = 0.5) +
geom_density(color = "blue") +
labs(x = "Pretul zirconiului", y = "Densitate") +
theme_minimal()
gemstone_split <- initial_split(GemStone, prop = 0.7)
gemstone_train <- training(gemstone_split)
gemstone_test <- testing(gemstone_split)
m1 <- rpart(
formula = price ~ .,
data = gemstone_train,
method = "anova"
)
m1
rpart.plot(m1)
plotcp(m1)
hyper_grid <- expand.grid(
minsplit = seq(7, 20, 1),
maxdepth = seq(6, 13, 1)
)
hyper_grid <- expand.grid(
minsplit = seq(7, 20, 1),
maxdepth = seq(6, 13, 1)
)
hyper_grid <- expand.grid(
minsplit = seq(7, 20, 1),
maxdepth = seq(6, 13, 1)
)
head(hyper_grid)
models <- list()
for (i in 1:nrow(hyper_grid)) {
minsplit <- hyper_grid$minsplit[i]
maxdepth <- hyper_grid$maxdepth[i]
models[[i]] <- rpart(
formula = price ~. ,
data = gemstone_train,
method = "anova",
control = list(minsplit = minsplit, maxdepth = maxdepth)
)
}
get_cp <- function(x) {
min <- which.min(x$cptable[,"xerror"])
cp <- x$cptable[min, "CP"]
return(cp)
}
get_min_error <- function(x) {
min <- which.min(x$cptable[, "xerror"])
xerror <- x$cptable[min, "xerror"]
return(xerror)
}
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
mutated_grid %>%
arrange(error) %>%
top_n(-6, wt=error)
optimal_tree <- rpart(
formula = price ~ .,
data = gemstone_train,
method = "anova",
control = list(minsplit = 15, maxdepth = 9, cp = 0.01)
)
rpart.plot(optimal_tree)
pred_optimal <- predict(optimal_tree, newdata = gemstone_test)
rmse_optimal <- RMSE(pred = pred_optimal, obs = gemstone_test$price)
print(paste("RMSE al modelului optimal: ", rmse_optimal))
library(modelr)
library(caret)
library(tidyverse)
library(caret)
library(rsample)
library(corrplot)
library(modeldata)
library(patchwork)
library(klaR)
library(ggplot2)
wine_data <- read_csv("wine_quality.csv")
library(tidyverse)
library(modelr)
library(caret)
library(rsample)
library(corrplot)
library(modeldata)
library(patchwork)
library(klaR)
library(ggplot2)
wine_data <- read_csv("wine_quality.csv")
